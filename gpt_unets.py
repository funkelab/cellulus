import torch
import torch.nn as nn
import torch.nn.functional as F
import pytorch_lightning as pl

'''
Contains code to create a simple pytorch lightning UNet in 2D and 3D, generated by ChatGPT 
'''
# -----------------------------
# 2D UNet code
class DoubleConv(nn.Module):
    # Convolutional Layer for 2D UNet
    def __init__(self, in_channels, out_channels):
        super().__init__()
        self.double_conv = nn.Sequential(
            nn.Conv2d(in_channels, out_channels, kernel_size=3, padding='same'),
            nn.BatchNorm2d(out_channels),
            nn.ReLU(inplace=True),
            nn.Conv2d(out_channels, out_channels, kernel_size=3, padding='same'),
            nn.BatchNorm2d(out_channels),
            nn.ReLU(inplace=True)
        )

    def forward(self, x):
        return self.double_conv(x)

class UNetFromGPT(nn.Module):
    '''
    Simple implementation of 2D UNet, for use in cellulus testing. 
    Generated by ChatGPT
    '''
    def __init__(self, in_channels=1, out_channels=2):
        super().__init__()

        self.conv_down1 = DoubleConv(in_channels, 64)
        self.conv_down2 = DoubleConv(64, 128)
        self.conv_down3 = DoubleConv(128, 256)
        self.conv_down4 = DoubleConv(256, 512)

        self.max_pool = nn.MaxPool2d(kernel_size=2, stride=2)

        self.conv_up3 = DoubleConv(256 + 512, 256)
        self.conv_up2 = DoubleConv(128 + 256, 128)
        self.conv_up1 = DoubleConv(64 + 128, 64)

        self.conv_last = nn.Conv2d(64, out_channels, kernel_size=1)

    def forward(self, x):
        # Encoder
        x1 = self.conv_down1(x)
        x2 = self.max_pool(x1)
        x3 = self.conv_down2(x2)
        x4 = self.max_pool(x3)
        x5 = self.conv_down3(x4)
        x6 = self.max_pool(x5)
        x7 = self.conv_down4(x6)

        # Decoder
        x = nn.functional.interpolate(x7, scale_factor=2, mode='bilinear', align_corners=True)
        x = self.conv_up3(torch.cat([x5, x], dim=1))
        x = nn.functional.interpolate(x, scale_factor=2, mode='bilinear', align_corners=True)
        x = self.conv_up2(torch.cat([x3, x], dim=1))
        x = nn.functional.interpolate(x, scale_factor=2, mode='bilinear', align_corners=True)
        x = self.conv_up1(torch.cat([x1, x], dim=1))

        # Output
        x = self.conv_last(x)

        return x

# -----------------------------
# 3D UNet code

class DoubleConv3D(nn.Module):
    # Convolutional Layer for 3D UNet
    def __init__(self, in_channels, out_channels):
        super().__init__()
        self.conv = nn.Sequential(
            nn.Conv3d(in_channels, out_channels, kernel_size=3, padding=1),
            nn.BatchNorm3d(out_channels),
            nn.ReLU(inplace=True),
            nn.Conv3d(out_channels, out_channels, kernel_size=3, padding=1),
            nn.BatchNorm3d(out_channels),
            nn.ReLU(inplace=True)
        )

    def forward(self, x):
        x = self.conv(x)
        return x

class Down3D(nn.Module):
    # Downsample Layer for 3D UNet
    def __init__(self, in_channels, out_channels):
        super().__init__()
        self.mpconv = nn.Sequential(
            nn.MaxPool3d(2),
            DoubleConv3D(in_channels, out_channels)
        )

    def forward(self, x):
        x = self.mpconv(x)
        return x

class Up3D(nn.Module):
    # Upsample Layer for 3D UNet
    def __init__(self, in_channels, out_channels, bilinear=True):
        super().__init__()

        if bilinear:
            self.up = nn.Upsample(scale_factor=2, mode='trilinear', align_corners=True)
            self.up = nn.Upsample(scale_factor=2, mode='trilinear', align_corners=True)
        else:
            self.up = nn.ConvTranspose3d(in_channels // 2, in_channels // 2, kernel_size=2, stride=2)

        self.conv = DoubleConv3D(in_channels, out_channels)

    def forward(self, x1, x2):
        x1 = self.up(x1)
        diffZ = x2.size()[2] - x1.size()[2]
        diffY = x2.size()[3] - x1.size()[3]
        diffX = x2.size()[4] - x1.size()[4]
        x1 = F.pad(x1, (diffX // 2, diffX - diffX // 2,
                        diffY // 2, diffY - diffY // 2,
                        diffZ // 2, diffZ - diffZ // 2))
        
        x = torch.cat([x2, x1], dim=1)
        x = self.conv(x)
        return x

class UNet3DFromGPT(pl.LightningModule):
    '''
    Simple implementation of 3D UNet, for use in cellulus testing. 
    Generated by ChatGPT
    '''
    def __init__(self, in_channels, out_channels, init_features=32):
        super().__init__()
        features = init_features
        self.down1 = DoubleConv3D(in_channels, features)
        self.down2 = Down3D(features, features * 2)
        self.down3 = Down3D(features * 2, features * 4)
        self.down4 = Down3D(features * 4, features * 8)
        self.bottom = DoubleConv3D(features * 8, features * 16)
        self.up1 = Up3D(features * 16 + features * 8, features * 8)
        self.up2 = Up3D(features * 8 + features * 4, features * 4)
        self.up3 = Up3D(features * 4 + features * 2, features * 2)
        self.up4 = Up3D(features * 2 + features, features)
        self.final_conv = nn.Conv3d(features, out_channels, kernel_size=1)

    def forward(self, x):
        # encoder
        x = x.unsqueeze(0)
        x1 = self.down1(x)
        x2 = self.down2(x1)
        x3 = self.down3(x2)
        x4 = self.down4(x3)
        x = self.bottom(x4)

        # decoder
        x = self.up1(x, x4)
        x = self.up2(x, x3)
        x = self.up3(x, x2)
        x = self.up4(x, x1)
        x = self.final_conv(x)

        return x    