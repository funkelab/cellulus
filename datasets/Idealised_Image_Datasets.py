from torch.utils.data.dataset import Dataset
import numpy as np
import torch
from idealised_image_utils import idealised_Nd_image, create_idealised_image
import random


class IdealisedImageDataset(Dataset):
    '''
    Create a pytorch dataset for the 2D idealised images generated by create_idealised_image by idealised_image_utils
    img_size: (int) side length of 2D square to generate
    radius: 
    num_objects: number of objects in each image
    batch_size: 
    object_radius: radius of objects
    '''
    def __init__(self,
                 img_size = 1000,
                 radius: int = 10, num_objects: int = 5, batch_size: int = 1, object_radius = 10):
        

        self.img_size = (img_size,img_size)
        self.batch_size = batch_size
        self.radius = radius
        self.num_objects = num_objects
        self.object_radius = object_radius

        # random.seed(0)
        self.prng1 = np.random.RandomState()
        num_objects = self.prng1.randint(1,self.num_objects)
        object_radius = self.prng1.randint(5,self.object_radius)
        # self.image = create_idealised_image(shape=self.img_size, number=self.num_objects,radius = self.object_radius, random_stream = prng1)
        self.image = create_idealised_image(shape=self.img_size, number=num_objects, radius = object_radius, random_stream = self.prng1, random_shapes=True)
        self.image = np.expand_dims(self.image,0)
        np.double(self.image)

    def __len__(self):
        # total number of possible patch pairs? Or number of patch pairs we want to create as a "complete" dataset?
        return 1000

    def __getitem__(self, idx):
        
        # idx as seed to random number gen, generate a pair of random indices between i_0 = [0,x-l], i_1 = [0,y-l]
        # these indices are the upper-left corder of patch A and B, thus the returned "vector" is the distance between 
        # the centre points of these two patches in each component (i.e. [x,y]).

        # the "image" returned by this function thus needs to be created with a gunpower request for two ROIs.
        # Furthermore, the gunpowder object(??) needs to be created in __init__ and stored in something like self.zarr

        num_objects = self.prng1.randint(1,self.num_objects*2)
        object_radius = self.prng1.randint(5,self.object_radius*2)
        # self.image = create_idealised_image(shape=self.img_size, number=self.num_objects,radius = self.object_radius, random_stream = prng1)
        self.image = create_idealised_image(shape=self.img_size, number=num_objects, radius = object_radius, random_stream = self.prng1)
        self.image = np.expand_dims(self.image,0)
        np.double(self.image)



        x_max = self.img_size[0]-(self.radius+1)
        y_max = self.img_size[1]-(self.radius+1)

        # we need both patches to be from the same slice and time point (for now). So we want to generate a random
        # z and t integer in the range of zarr_shape[0] and zarr_shape[1]
        # print('generating random indices...')

        # seed the random number generator with idx
        random.seed(idx)

        # randomly generated image coordinated for patch A:
        x_A = np.random.randint(low=self.radius,high=x_max,size=self.batch_size)
        y_A = np.random.randint(low=self.radius,high=y_max,size=self.batch_size)
        # randomly generated image coordinated for patch B:
        x_B = x_A + np.random.randint(low=-self.radius,high=self.radius,size=self.batch_size)
        y_B = y_A + np.random.randint(low=-self.radius,high=self.radius,size=self.batch_size)
        # print('random indeces are:',t,z,x_A,y_A,x_B,y_B)
        
        # return [np.repeat(np.expand_dims(self.image,[0]),self.batch_size,0), torch.tensor(np.array([x_A,y_A]).transpose()), torch.tensor(np.array([x_B,y_B]).transpose())]
        return [self.image, torch.tensor(np.array([x_A,y_A]).transpose()), torch.tensor(np.array([x_B,y_B]).transpose())]


class Idealised3DImageDataset(Dataset):
    '''
    Create a pytorch dataset for the 3D idealised images generated by idealised_Nd_image by idealised_image_utils
    img_size: (int) side length of 3D cube to generate
    radius: 
    num_objects: number of spheres in each image
    batch_size: 
    object_radius:radius of spheres
    '''
    def __init__(self,
                 img_size = 1000,
                 radius: int = 10, num_objects: int = 5, batch_size: int = 1, object_radius = 10):
        

        self.img_size = (img_size,img_size,img_size)
        self.batch_size = batch_size
        self.radius = radius
        self.num_objects = num_objects
        self.object_radius = object_radius

        # random.seed(0)
        self.prng1 = np.random.RandomState()
        num_objects = self.prng1.randint(1,self.num_objects)
        # object_radius = self.prng1.randint(5,self.object_radius)
        self.image = idealised_Nd_image(shape=self.img_size, number=num_objects, radius = object_radius)
        # self.image = np.expand_dims(self.image,0)
        self.image = np.float32(self.image)

    def __len__(self):
        # total number of possible patch pairs? Or number of patch pairs we want to create as a "complete" dataset?
        return 1000

    def __getitem__(self, idx):
        
        # idx as seed to random number gen, generate a pair of random indices between i_0 = [0,x-l], i_1 = [0,y-l]
        # these indices are the upper-left corder of patch A and B, thus the returned "vector" is the distance between 
        # the centre points of these two patches in each component (i.e. [x,y]).

        # the "image" returned by this function thus needs to be created with a gunpower request for two ROIs.
        # Furthermore, the gunpowder object(??) needs to be created in __init__ and stored in something like self.zarr

        num_objects = self.prng1.randint(1,self.num_objects*2)
        object_radius = self.prng1.randint(5,self.object_radius*2)
        self.image = idealised_Nd_image(shape=self.img_size, number=num_objects, radius = object_radius)
        # self.image = np.expand_dims(self.image,0)
        self.image = np.float32(self.image)

        # x_max = self.img_size[0]-(self.radius+1)
        # y_max = self.img_size[1]-(self.radius+1)
        # z_max = self.img_size[2]-(self.radius+1)

        x_max = self.img_size[0]
        y_max = self.img_size[1]
        z_max = self.img_size[2]

        # we need both patches to be from the same slice and time point (for now). So we want to generate a random
        # z and t integer in the range of zarr_shape[0] and zarr_shape[1]
        # print('generating random indices...')

        # seed the random number generator with idx
        random.seed(idx)

        # # randomly generated image coordinated for patch A:
        # x_A = np.random.randint(low=self.radius,high=x_max,size=self.batch_size)
        # y_A = np.random.randint(low=self.radius,high=y_max,size=self.batch_size)
        # z_A = np.random.randint(low=self.radius,high=z_max,size=self.batch_size)

        # # randomly generated image coordinated for patch B:
        # x_B = np.random.randint(low=self.radius,high=x_max,size=self.batch_size)
        # y_B = np.random.randint(low=self.radius,high=y_max,size=self.batch_size)
        # z_B = np.random.randint(low=self.radius,high=z_max,size=self.batch_size)

        # randomly generated image coordinated for patch A:
        x_A = np.random.randint(low=0,high=x_max,size=self.batch_size)
        y_A = np.random.randint(low=0,high=y_max,size=self.batch_size)
        z_A = np.random.randint(low=0,high=z_max,size=self.batch_size)

        # randomly generated image coordinated for patch B:
        x_B = np.random.randint(low=0,high=x_max,size=self.batch_size)
        y_B = np.random.randint(low=0,high=y_max,size=self.batch_size)
        z_B = np.random.randint(low=0,high=z_max,size=self.batch_size)

        
        # # randomly generated image coordinated for patch B:
        # x_B = x_A + np.random.randint(low=-self.radius,high=self.radius,size=self.batch_size)
        # y_B = y_A + np.random.randint(low=-self.radius,high=self.radius,size=self.batch_size)
        # z_B = z_A + np.random.randint(low=-self.radius,high=self.radius,size=self.batch_size)
        # print('random indeces are:',t,z,x_A,y_A,x_B,y_B)

        
        return [self.image,
                 torch.tensor(np.array([x_A,y_A,z_A]).transpose()), 
                 torch.tensor(np.array([x_B,y_B,z_B]).transpose())]